# OSの歴史とプロセスモデルへの収束

*作成日: 2026-01-17*
*ステータス: 初稿*

## 概要

LOSの設計を考える上で、既存OSがどのように発祥し進化してきたか、そしてなぜ「プロセス」という抽象化に収束したのかを理解することは重要である。本ドキュメントでは、OSの歴史的系譜と、プロセスモデルへの収束の必然性・偶然性を考察する。

---

## OSの発祥と進化分類

### 第1世代: バッチ処理（1950年代）

- **GM-NAA I/O** (1956) - 最初のOS的存在
- ジョブをまとめて順次実行
- 人間がオペレーター

### 第2世代: タイムシェアリング（1960年代）

- **CTSS** (1961) - MIT
- **Multics** (1969) - 階層ファイルシステム、メモリ保護など多くの概念を確立
- 複数ユーザーが同時利用可能に

### 第3世代: UNIX系（1969年〜）

```
Multics（複雑すぎた）
    ↓ アンチテーゼとして
UNIX (1969, Bell Labs) ─── "Small is Beautiful"
    ├── BSD系 → FreeBSD, macOS (Mach+BSD)
    ├── System V系 → Solaris, AIX
    └── Linux (1991) → Android, ChromeOS
```

### 第4世代: マイクロカーネル（1980年代〜）

- **Mach** (CMU) - メッセージパッシング
- **MINIX** - 教育用、Linuxの触発元
- **L4** - 高性能マイクロカーネル
- **QNX** - リアルタイム、車載など
- **seL4** - 形式検証済み

### 第5世代: 研究・実験系（1990年代〜）

- **Singularity** (MS Research) - 型安全、管理コード
- **House** - Haskell OS
- **Unikernel** - ライブラリOS

---

## 進化の軸

| 軸 | 変遷 |
|---|---|
| **カーネル構造** | モノリシック → マイクロ → ハイブリッド |
| **言語** | アセンブリ → C → Rust/型安全言語 |
| **安全性** | テスト → 静的解析 → 形式検証 |
| **抽象化** | ハードウェア直接 → 仮想化 → コンテナ |

---

## Multicsの位置づけ: 直系先祖か？

### 結論

**「直系」は言い過ぎ、だが「最も影響を与えた先祖」ではある。**

### Multicsの概念的貢献（継承されたもの）

- 階層ファイルシステム
- プロセスの概念
- シェル（コマンドインタプリタ）
- メモリの仮想化
- アクセス制御リスト（ACL）
- 動的リンク

### 「直系」ではない理由

**UNIXはMulticsの「アンチテーゼ」として生まれた。**

```
Multics: "すべてを統合した完璧なシステムを"
    ↓ 失敗（複雑すぎ、遅すぎ、高すぎ）

UNIX: "シンプルに、一つのことをうまくやれ"
```

Ken Thompsonの言葉:
> "Multicsから学んだ最大の教訓は、何をすべきでないかだった"

### 系譜図

```
CTSS (1961)
   ↓ 発展
Multics (1969) ──────────────────┐
   ↓ 反発・批判として            │概念は継承
UNIX (1969) ←────────────────────┘
   ↓
現代OS（Linux, BSD, macOS）
```

### 他の系譜

| 現代OS | 直接の先祖 | Multicsとの関係 |
|--------|-----------|----------------|
| Linux/macOS | UNIX | 間接的（反面教師経由） |
| Windows NT | VMS, OS/2 | ほぼ無関係 |
| 組み込みRTOS | 独自発展 | 無関係 |

---

## UNIX系以外の系譜

### VMS (Virtual Memory System)

#### 発祥
- **1977年**, DEC (Digital Equipment Corporation)
- **VAX**アーキテクチャ向けに開発
- 主導者: **Dave Cutler**

#### 設計思想
- 堅牢性・信頼性重視（ミッションクリティカル用途）
- クラスタリング（複数マシンを1つのシステムとして）
- 強力なジョブ管理・バッチ処理

#### 系譜
```
VMS (1977, DEC)
   ↓ Dave Cutlerが Microsoft へ移籍
Windows NT (1993)
   ↓
Windows 2000/XP/7/10/11
```

Windows NTはVMSの設計思想を色濃く継承。Cutlerが同じ人物だからである。

### OS/2

#### 発祥
- **1987年**, **IBM + Microsoft** 共同開発
- MS-DOSの後継として企画
- IBM PS/2ハードウェアと同時発表

#### 設計思想
- MS-DOSとの互換性を保ちつつ
- プリエンプティブマルチタスク
- プロテクトモード活用（メモリ保護）

#### 歴史
```
1987: IBM + MS 共同で OS/2 1.0
1990: Windows 3.0 大成功 ← MSの本音が見える
1991: IBM・MS 決裂
      ├── IBM: OS/2 継続 → OS/2 Warp (1994)
      └── MS: Windows NT 開発へ
1996: OS/2 事実上終焉
```

#### 失敗の原因
- IBMとMSの政治的対立
- Windows 3.0/95の成功
- 開発者エコシステムを獲得できず

### 系譜まとめ

```
          ┌─── Multics ───→ UNIX ──→ Linux, macOS
          │      (反面教師)
          │
学術/研究 ─┤
          │
          └─── CTSS系の影響

          ┌─── VMS (DEC) ───→ Windows NT ──→ 現代Windows
          │
企業/商用 ─┤
          ├─── CP/M ───→ MS-DOS ───→ Windows 9x（消滅）
          │
          └─── OS/2 (IBM+MS) ───→ 消滅（Warp後）
```

---

## プロセスモデルへの収束

### 問い

なぜ異なる系譜のOSが全て同じ「プロセス」という抽象化に収束したのか？

### 表面的な答え: ハードウェア制約

```
Von Neumannアーキテクチャ
├── 命令を順次実行
├── 状態（レジスタ、メモリ）を持つ
└── 1つのCPUを時分割で共有

→ 「状態の保存・復元の単位」としてプロセスが自然に生まれた
```

MMU（メモリ管理ユニット）の登場で「隔離された実行単位」が効率的に実現可能になった。

### より深い答え: 思考の固定化

```
1960年代: 様々なモデルが競合
   ↓
Multics/UNIX の成功
   ↓
プロセスモデルが「正解」として固定
   ↓
以降のOSは全てこれを前提に設計
```

VMS、OS/2、Windows NT も**疑問を持たずに**プロセスを採用した。

### 代替案は存在した

| モデル | 特徴 | なぜ主流にならなかったか |
|--------|------|------------------------|
| **アクターモデル** | メッセージパッシング、共有状態なし | 既存ハードウェアと乖離 |
| **データフロー** | データの流れで計算を記述 | 専用ハードウェア必要 |
| **CSP/π計算** | 通信するプロセスの代数 | 理論先行、実装困難 |
| **遅延評価+並行性** | 必要になったら計算 | 実行効率の予測困難 |

### プロセスモデルが勝った本当の理由

1. **Cとの共犯関係**
   - UNIX = C言語で書かれた
   - Cの実行モデル = 逐次実行 + 状態変更
   - プロセス = 「Cプログラムの実行インスタンス」として完璧に対応

2. **既存資産の呪縛**
   - 一度プロセスモデルで書かれたコードは、プロセスモデルを前提とする
   - 互換性維持 → 同じモデルを継続

3. **教育の再生産**
   - OSの教科書 = プロセスモデル
   - 学生 → エンジニア → 同じモデルで設計

---

## LOSへの示唆

### プロセスは「発見」ではなく「発明」

λ計算の視点から見ると:

```
プロセス = 状態 + 状態遷移の列
λ計算   = 式 + 簡約（書き換え）

根本的に異なるモデル
```

### LOSが問うべきこと

| 従来の概念 | 問い直し |
|-----------|---------|
| プロセス | 本当に必要？ λ式の評価で代替できないか？ |
| スレッド | 並行性は評価戦略で表現できないか？ |
| 共有メモリ | Linear Typesで不要にできないか？ |
| IPC | Session Typesで型安全に表現できないか？ |

### Multicsの教訓

1. **複雑さは敵** → λ計算のシンプルさを活かす
2. **理想を追いすぎない** → 段階的に実現可能なものから

### VMSとOS/2の教訓

- **VMS**: 信頼性を重視 → 型安全・形式検証と通じる志向
- **OS/2**: 互換性に縛られて自由な設計ができなかった → 新規設計の重要性

**「白紙から設計できる」LOSの立場は、ある意味で贅沢な状況である。**

**全員が同じなのは「正しいから」ではなく「疑わなかったから」かもしれない。**

---

## 参考文献

- Corbató, F. J., & Vyssotsky, V. A. (1965). Introduction and overview of the Multics system.
- Ritchie, D. M., & Thompson, K. (1974). The UNIX Time-Sharing System.
- Cutler, D. (1988). The Design of the VAX/VMS Operating System.
- Tanenbaum, A. S. (2014). Modern Operating Systems (4th ed.).

---

*このドキュメントは、LOSプロジェクトにおける既存OSの歴史的理解と、プロセスモデルへの批判的考察をまとめたものである。*
