# LOS設計哲学：λ計算を基盤としたOS設計パラダイム

## 概要

本プロジェクトは、純粋関数型言語Haskellを用いて、**新しいOS設計パラダイムの探求**を目的とする。既存OSの概念をHaskellに「翻訳」するのではなく、λ計算を理論的基盤として**根本からOSを再設計**する。

---

## 1. 背景と動機

### 1.1 既存OS設計の限界

現在のOS概念（プロセス、スレッド、ファイル、システムコール）は1960〜70年代のハードウェア制約から生まれた。これらは：

- チューリングマシン的世界観に基づく
- 状態の変異（mutation）を中心とした設計
- 副作用が暗黙的に発生
- 並行処理における競合状態が起きやすい

### 1.2 λ計算ベースの可能性

λ計算は計算理論的にチューリングマシンと等価だが、世界の見方が根本的に異なる：

| 観点 | チューリングマシン的 | λ計算的 |
|------|---------------------|---------|
| 中心概念 | 状態遷移 | 関数適用 |
| データ | 変更可能 | 不変 |
| 副作用 | 暗黙的 | 明示的（型で表現） |
| 合成 | 手続きの連結 | 関数合成 |

---

## 2. 設計原理

### 2.1 OSの本質的定義

```
OS = リソースを計算に割り当て、計算の合成を可能にするシステム
```

従来の「プロセス管理」「メモリ管理」という機能分割ではなく、**「計算」と「リソース」と「効果」**を中心に据える。

### 2.2 核となる概念

#### Computation as First-Class Citizen

「プロセス」ではなく「計算」を第一級市民として扱う：

```haskell
type Computation a = Resources → (a, Resources)
```

計算は値として扱え、合成でき、部分適用できる。

#### Effect System as Capability System

型レベルで「何ができるか」を表現：

```haskell
readFile  :: HasCapability FileRead  m => FilePath → m ByteString
writeNet  :: HasCapability NetWrite  m => Socket → ByteString → m ()
```

コンパイル時に権限違反を検出できる。

#### Linear Types for Resource Management

リソースの線形使用を型で保証：

```haskell
close :: FileHandle ⊸ IO ()  -- 一度しか使えない
free  :: Ptr a ⊸ IO ()        -- Use-after-free防止
```

#### Reactive Streams as System Model

OSを「イベントストリームの変換器」として設計：

```
Events → [OS Transformation] → Effects
```

---

## 3. 従来概念の再解釈

| 従来の概念 | λ計算的再解釈 |
|-----------|--------------|
| プロセス | 独立した計算（Computation） |
| スレッド | 並行な計算の合成 |
| ファイル | 永続化された値へのアクセス経路 |
| システムコール | 効果（Effect）の発行 |
| 割り込み | イベントストリームへの入力 |
| スケジューリング | 計算の評価戦略の選択 |

---

## 4. 期待される利点

### 4.1 型安全性

- 副作用の有無が型で明示される
- リソースの誤使用がコンパイルエラーになる
- 権限違反が静的に検出される

### 4.2 形式検証可能性

- 純粋関数は数学的証明が適用可能
- 参照透過性により挙動が予測可能
- 同じ入力には常に同じ出力

### 4.3 並行処理の安全性

- 共有可変状態がない
- 競合状態が構造的に排除される
- 合成による並行性の表現

### 4.4 テスタビリティ

- 純粋関数は入出力だけでテスト可能
- カーネルロジックの単体テストが容易
- 再現性のあるテスト環境

---

## 5. 技術的課題

### 5.1 ガベージコレクション

現行GHCのGCは非並行・非インクリメンタルであり、リアルタイム性に影響する。

対策案：
- リアルタイムGCの導入
- 特定領域でのマニュアルメモリ管理
- リージョンベースのメモリ管理

### 5.2 ハードウェアとの接点

純粋関数とハードウェアI/Oの橋渡しが必要。

対策：
- 最小限のC/アセンブリマイクロカーネル
- FFI（Foreign Function Interface）の活用
- モナディックインターフェースによる抽象化

### 5.3 パフォーマンス

抽象化のコストとのトレードオフ。

対策：
- 適切な最適化（インライン展開、融合変換）
- クリティカルパスの特定と最適化
- ベンチマークに基づく改善

---

## 6. 参考事例

### 6.1 既存のHaskell OS

- **House**: Haskellで書かれたデモOS、ネットワークスタック実装
- **HaLVM**: Xen上で動作するHaskell仮想マシン（Galois社）

### 6.2 関連研究

- **Singularity OS**: Microsoft Research、型安全なOS
- **seL4**: 形式検証されたマイクロカーネル
- **Algebraic Effects**: 効果の代数的表現

---

## 7. 次のステップ

1. コア概念の形式的定義
2. 型システムの設計
3. 最小プロトタイプの実装
4. 評価と改善

---

## 参考文献

- [House - Haskell OS](https://programatica.cs.pdx.edu/House/)
- [HaLVM Wiki](https://github.com/GaloisInc/HaLVM/wiki)
- [OSDev Wiki - Haskell](https://wiki.osdev.org/Haskell)
- [A principled approach to OS construction in Haskell (ACM)](https://dl.acm.org/doi/10.1145/1086365.1086380)

---

*作成日: 2025-12-30*
*ステータス: 初期設計フェーズ*
